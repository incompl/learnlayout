# Korean

global.title: "CSS 레이아웃을 배웁시다"
global.short_title: "CSS"
global.home: "홈"
global.toc: "목차"
global.next: "다음"
global.previous: "이전"
global.feedback: "문제 / 피드백"

util.extra_credit: "보충 내용"
util.ipsum: "나랏말ᄊᆞ미 中듀ᇰ國귁에 달아 文문字ᄍᆞᆼ와로 서르 ᄉᆞᄆᆞᆺ디 아니ᄒᆞᆯᄊᆡ 이런 젼ᄎᆞ로 어린百ᄇᆡᆨ姓셔ᇰ이 니르고져 호ᇙ 배 이셔도 ᄆᆞᄎᆞᆷ내 제 ᄠᅳ들 시러 펴디 몯ᄒᆞᇙ 노미 하니라 내 이ᄅᆞᆯ 爲윙ᄒᆞ야 어엿비 너겨 새로 스믈여듧 字ᄍᆞᆼᄅᆞᆯ ᄆᆡᇰᄀᆞ노니 사ᄅᆞᆷ마다 ᄒᆡᅇᅧ 수ᄫᅵ 니겨 날로 ᄡᅮ메 便뼌安ᅙᅡᆫ킈 ᄒᆞ고져 ᄒᆞᇙ ᄯᆞᄅᆞ미니라ㄱ·ᄂᆞᆫ:엄쏘·리·니君군ㄷ字·ᄍᆞᆼ·처ᅀᅥᆷ·펴·아·나ᄂᆞᆫ소·리·ᄀᆞᄐᆞ·니ᄀᆞᆯ·ᄫᅡ·쓰·면虯뀨ᇢㅸ字·ᄍᆞᆼ·처ᅀᅥᆷ·펴·아·나ᄂᆞᆫ소·리·ᄀᆞ·ᄐᆞ니·라ㅋ·ᄂᆞᆫ:엄쏘·리·니快·쾡ㆆ字·ᄍᆞᆼ·처ᅀᅥᆷ·펴·아·나ᄂᆞᆫ소·리·ᄀᆞ·ᄐᆞ니·라ㆁ·ᄂᆞᆫ:엄쏘·리·니業·ᅌᅥᆸ字·ᄍᆞᆼ·처ᅀᅥᆷ·펴·아·나ᄂᆞᆫ소·리·ᄀᆞ·ᄐᆞ니·라ㄷ·ᄂᆞᆫ·혀쏘·리·니斗두ᇢㅸ字·ᄍᆞᆼ·처ᅀᅥᆷ·펴·아·나ᄂᆞᆫ소·리·ᄀᆞ·ᄐᆞ니ᄀᆞᆯ·ᄫᅡ·쓰·면覃땀ㅂ字·ᄍᆞᆼ·처ᅀᅥᆷ·펴·아·나ᄂᆞᆫ소·리·ᄀᆞ·ᄐᆞ니·라"
util.nav.1: "홈"
util.nav.2: "타코 메뉴"
util.nav.3: "초안 목록"
util.nav.4: "시간"
util.nav.5: "방향"
util.nav.6: "연락처"

index.1: "이 사이트에서는 모든 웹 사이트의 레이아웃에 사용되는 CSS의 기초를 다룹니다."
index.2: "이곳에서는 여러분이 선택자와 프로퍼티, 값이 무엇인지 알고 있다고 가정합니다. 그리고 레이아웃 작업이 여러분을 짜증 나게 만드는 작업일 수도 있겠지만 이미 한두 가지 레이아웃을 알고 있다고 가정합니다. HTML과 CSS를 처음부터 배우고 싶다면 <a href=\"http://learn.shayhowe.com/html-css/\">이 튜토리얼</a>을 참고하세요. 그렇지 않다면 이 튜토리얼이 여러분의 다음 프로젝트에 도움될 수 있을지 알아봅시다."
index.translator: "한국어 번역: 이대엽"
index.get_started: "시작"

no_layout.title: "레이아웃 없음"
no_layout.1: "페이지에 콘텐츠가 기다란 한 줄로만 나오게 하고 싶다면 아무런 레이아웃을 지정하지 않는 방법도 괜찮습니다. 하지만 사용자가 브라우저 창을 굉장히 넓게 키운다면 콘텐츠를 읽기가 굉장히 불편해질 것입니다. 각 줄이 끝날 때마다 다음 줄로 가려면 오른쪽에서 왼쪽으로 먼 거리를 움직여야 하니까요. 브라우저 크기를 조정해서 이게 무슨 의미인지 확인해 보세요!"
no_layout.2: "이 문제를 해결하기에 앞서 굉장히 중요한 <code>display</code> 프로퍼티에 관해 확실히 알아봅시다."

display.title: "\"display\" 프로퍼티"
display.intro: "<code>display</code>는 CSS에서 레이아웃을 제어하기 위한 가장 중요한 프로퍼티입니다. 모든 엘리먼트에는 엘리먼트의 유형에 따라 기본 표시값이 있습니다. 대부분의 엘리먼트에 대한 기본값은 보통 <code>block</code>이나 <code>inline</code>입니다. 블록 엘리먼트는 블록 레벨 엘리먼트라고 부를 때도 있으며, 인라인 엘리먼트는 늘 인라인 엘리먼트라고 부릅니다."
display.block.title: "block"
display.block: "<code>div</code>는 표준 블록 레벨 엘리먼트입니다. 블록 레벨 엘리먼트는 새 줄에서 시작해 좌우로 최대한 늘어납니다. 자주 볼 수 있는 다른 블록 레벨 엘리먼트로 <code>p</code>와 <code>form</code>이 있으며, HTML5에서 새로 추가된 엘리먼트로 <code>header</code>와 <code>footer</code>, <code>section</code> 등이 있습니다."
display.inline.title: "inline"
display.inline.1: "<code>span</code>은 표준 인라인 엘리먼트입니다. 인라인 엘리먼트는 단락 안에서"
display.inline.2: "이처럼"
display.inline.3: "해당 단락의 흐름을 방해하지 않은 채로 텍스트를 감쌀 수 있습니다. 링크에 사용하는 <code>a</code> 엘리먼트는 가장 흔히 볼 수 있는 인라인 엘리먼트입니다."
display.none.title: "none"
display.none.1: "흔히 볼 수 있는 또 한 가지 <code>display</code> 값은 <code>none</code>입니다. <code>script</code>와 같은 일부 특별한 엘리먼트에서는 <code>none</code>을 기본값으로 사용하기도 합니다. 이 값은 자바스크립트에서 엘리먼트를 실제로 삭제하고 재생성하지 않고도 엘리먼트를 보이고 감추는 데 흔히 사용됩니다."
display.none.2: "이것은 <code>visibility</code>와 다릅니다. <code>display</code>를 <code>none</code>으로 설정하면 엘리먼트가 마치 존재하지 않는 것처럼 페이지가 렌더링됩니다. <code>visibility: hidden;</code>으로 설정하면 엘리먼트가 감춰질 테지만 해당 엘리먼트는 완전히 보이지 않게 되더라도 여전히 공간을 차지합니다."
display.other.title: "다른 <code>display</code> 값"
display.other: "<code>list-item</code>과 <code>table</code> 같은 다른 좀 더 특이한 <code>display</code> 값도 있습니다. <a href=\"https://developer.mozilla.org/en-US/docs/CSS/display\">전체 목록은 이곳을 참고하세요.</a> <code>inline-block</code>과 <code>flex</code>에 대해서는 나중에 살펴보겠습니다."
display.extra: "앞에서 언급했듯이 모든 엘리먼트에는 기본 표시 타입이 지정돼 있습니다. 하지만 <em>언제든지</em> 이러한 기본값을 재정의할 수 있습니다! 인라인 div를 만드는 것은 적절하지 않겠지만 이를 이용해 특별한 시맨틱을 지닌 엘리먼트의 표시 방식을 조정할 수 있습니다. 흔히 볼 수 있는 예로 가로 메뉴를 만들기 위해 인라인 <code>li</code> 엘리먼트를 만드는 것이 있습니다."
margin_auto.title: "margin: auto;"
margin_auto.1: "블록 레벨 엘리먼트의 <code>width</code>를 설정하면 컨테이너의 좌우 가장자리로 늘어나지 않게 할 수 있습니다. 그런 다음 좌우 마진을 <code>auto</code>로 설정해 해당 엘리먼트를 컨테이너 안에서 가로 중앙에 오게 할 수 있습니다. 엘리먼트는 여러분이 지정한 너비를 차지할 테고, 나머지 공간은 두 마진에 균등하게 나눠질 것입니다."
margin_auto.2: "브라우저 창이 엘리먼트 너비보다 좁을 때 유일하게 문제가 발생합니다. 브라우저에서는 페이지에 가로 스크롤바를 만들어 이 문제를 해결합니다. 그럼 이 같은 상황을 개선해 봅시다..."
max_width.title: "max-width"
max_width.1: "이러한 상황에서 <code>width</code> 대신 <code>max-width</code>를 사용하면 브라우저가 작은 창을 처리하는 방식을 개선할 수 있습니다. 이것은 사이트를 모바일 환경에서도 사용할 수 있게 만들 때 중요합니다. 이 페이지의 크기를 조절해서 어떻게 바뀌었는지 확인해 보세요!"
max_width.2: "그나저나 <code>max-width</code>는 IE7+를 비롯한 <a href=\"http://caniuse.com/#search=max-width\">주요 브라우저에서 모두 지원되므로</a> 안심하고 사용하셔도 됩니다."
box_model.title: "박스 모델"
box_model.intro: "너비에 관해 이야기하는 김에 너비와 관련해서 반드시 알아둬야 할 <em>박스 모델</em>에 대해 이야기하겠습니다. 엘리먼트의 너비를 설정할 경우 해당 엘리먼트는 실제로 여러분이 설정한 것보다 크게 나타날 수 있습니다. 이것은 엘리먼트의 테두리와 패딩이 지정된 너비 이상으로 엘리먼트를 늘리기 때문입니다. 다음 예제를 보시면 너비값을 동일하게 설정했는데도 결과적으로 크기가 다릅니다."
box_model.simple: "저는 더 작습니다..."
box_model.fancy: "그리고 전 더 커요!"
box_model.outro: "오랫동안 이 문제의 해법은 너비값을 조절하는 것이었습니다. CSS 코드를 작성하는 사람들은 패딩과 테두리를 빼는 식으로 늘 원하는 것보다 작은 너비값을 지정해왔습니다. 다행히도 이제 더는 그렇게 하지 않아도 됩니다."

box_sizing.title: "box-sizing"
box_sizing.1: "오랜 시간에 걸쳐 사람들은 너비값을 조절하는 해법이 그다지 만족스럽지 않다는 사실을 깨닫고 <code>box-sizing</code>이라고 하는 새로운 CSS 프로퍼티를 만들어냈습니다. 엘리먼트에 <code>box-sizing</code>을 지정하면 해당 엘리먼트의 패딩과 테두리가 더는 너비를 늘리지 않습니다. 다음은 이전 페이지와 동일한 예제이지만 두 엘리먼트에 모두 <code>box-sizing: border-box;</code>를 지정했습니다."
box_sizing.simple: "이제 크기가 같아졌어요!"
box_sizing.fancy: "야호!"
box_sizing.2: "이 방법이 훨씬 더 낫기 때문에 페이지 상의 모든 엘리먼트가 항상 이런 식으로 동작하게 만들고 싶은 분들도 있습니다. 그런 분들은 페이지에 다음과 같은 CSS 코드를 집어넣습니다."
box_sizing.3: "이렇게 하면 모든 엘리먼트가 항상 이처럼 더 직관적인 방식으로 크기가 지정됩니다."
box_sizing.4: "<code>box-sizing</code>은 다소 근래에 생긴 프로퍼티라서 지금 당장은 예제에서 한 것처럼 <code>-webkit-</code>이나 <code>-moz-</code> 접두사를 붙여야 합니다. 이 기법은 특정 브라우저에서 실험적인 기능들을 활성화하는 데 사용됩니다. 아울러 이 기법은 <a href=\"http://caniuse.com/#search=box-sizing\">IE8+</a>에서만 사용할 수 있다는 점도 염두에 두세요."
position.title: "position"
position.intro: "좀 더 복잡한 레이아웃을 만들기 위해서는 <code>position</code> 프로퍼티에 관해 살펴볼 필요가 있습니다. <code>position</code> 프로퍼티에는 다양한 값을 설정할 수 있으며, 각 값의 이름은 제대로 지어지지 않아서 기억하기가 불가능합니다. 그럼 지금부터 하나씩 살펴보기로 하고, 이 페이지를 즐겨찾기에 추가해 둬야 할 수도 있습니다."
position.static.title: "static"
position.static.1: "<code>static</code>은 기본값입니다. <code>position: static;</code>이 설정된 엘리먼트는 그다지 특별한 방식으로 위치가 지정된 것이 아닙니다. 정적(static) 엘리먼트는 위치가 <em>지정된 것이 아니라고</em> 표현하며, <code>static</code>이 아닌 다른 값으로 지정된 엘리먼트에 대해 <em>위치가 지정됐다고</em> 표현합니다."
position.relative.title: "relative"
position.relative.1: "<code>relative</code>는 별도의 프로퍼티를 지정하지 않는 이상 <code>static</code>과 동일하게 동작합니다."
position.relative.2: "상대 위치가 지정된 엘리먼트에 <code>top</code>이나 <code>right</code>, <code>bottom</code>, <code>left</code>를 지정하면 기본 위치와 다르게 위치가 조정됩니다. 다른 콘텐츠는 해당 엘리먼트에서 남긴 공백에 맞춰 들어가게끔 조정되지 않을 것입니다."
position.fixed.title: "fixed"
position.fixed.1: "고정(fixed) 엘리먼트는 뷰포트(viewport)에 상대적으로 위치가 지정되는데, 이는 페이지가 스크롤되더라도 늘 같은 곳에 위치한다는 뜻입니다. <code>relative</code>와 마찬가지로 <code>top</code>이나 <code>right</code>, <code>bottom</code>, <code>left</code> 프로퍼티가 사용됩니다."
position.fixed.2: "페이지의 우측 하단 구석에 고정된 엘리먼트가 있다는 사실을 눈치채셨을 겁니다. 이 엘리먼트를 눈여겨보세요. 다음은 이 엘리먼트를 그 자리에 놓이게 만든 CSS 코드입니다."
position.fixed.3: "고정 엘리먼트는 평소대로라면 있었을 법한 공백을 페이지에 남기지 않습니다."
position.fixed.4: "모바일 브라우저의 경우 고정 엘리먼트 지원이 굉장히 불안정합니다. <a href=\"http://bradfrostweb.com/blog/mobile/fixed-position/\">이와 관련된 사항은 이곳에서 좀 더 자세히 확인하실 수 있습니다</a>."
position.fixed.example: "안녕하세요! 아직은 저한테 관심을 보이지 마세요."
position.absolute.title: "absolute"
position.absolute.1: "<code>absolute</code>는 가장 다루기 까다로운 위치 지정 값입니다. <code>absolute</code>는 뷰포트에 상대적으로 위치가 지정되는 게 아니라 <em>가장 가까운 곳에 위치한 조상 엘리먼트</em>에 상대적으로 위치가 지정된다는 점을 제외하면 <code>fixed</code>와 비슷하게 동작합니다. 절대 위치가 지정된 엘리먼트가 기준으로 삼는 조상 엘리먼트가 없으면 문서 본문(document body)을 기준으로 삼고, 페이지 스크롤에 따라 움직입니다. \"위치가 지정된\" 엘리먼트는 <code>position</code>이 <code>static</code>으로 지정되지 않은 엘리먼트를 가리킨다는 사실을 기억하세요."
position.absolute.2: "다음은 간단한 예제입니다."
position.absolute.relative: "이 엘리먼트는 상대 위치가 지정돼 있습니다. 이 엘리먼트가 <code>position: static;</code>이었다면 절대 위치가 지정된 자식 엘리먼트는 이 엘리먼트에서 빠져나와 문서 본문을 기준으로 상대 위치가 지정됐을 것입니다."
position.absolute.absolute: "이 엘리먼트에는 절대 위치가 지정돼 있습니다. 부모 엘리먼트를 기준으로 상대 위치가 정해져 있지요."
position.absolute.3: "여기서 배운 내용은 꽤나 까다롭지만 멋진 CSS 레이아웃을 만드는 데 필수적인 내용입니다. 다음 페이지에서는 좀 더 실전 예제에서 <code>position</code>을 사용해 보겠습니다."

position_example.title: "위치 지정 예제"
position_example.1: "아래의 위치 지정 예제는 실제 예제에서 쓰기에 좀 더 적절할지도 모릅니다. 다음은 다소 현실적인 페이지 레이아웃입니다."
position_example.section.1: "<code>section</code>에 지정한 <code>margin-left</code> 스타일은 <code>nav</code>가 들어갈 공간을 만들어 줍니다. 그렇게 하지 않으면 절대 및 정적 엘리먼트가 겹칠 것입니다."
position_example.section.2: "브라우저 크기를 조절했을 때 어떻게 되는지 확인해 보세요. 잘 작동할 겁니다!"
position_example.2: "이 예제에서는 컨테이너의 높이가 내비게이션보다 높기 때문에 제대로 동작합니다. 그렇지 않다면 내비게이션 영역이 컨테이너 밖으로 흘러넘칠 것입니다. 이어지는 페이지에서는 각기 장단점이 있는 다른 레이아웃 기법을 살펴보겠습니다."
position_example.footer: "고정 헤더나 푸터를 사용한다면 그것들이 들어갈 공간을 마련해 줘야 합니다! 여기서는 <code>body</code>에 <code>margin-bottom</code>을 집어넣었습니다."

float.title: "float"
float.1: "레이아웃을 잡는 데 사용하는 또 하나의 CSS 프로퍼티는 바로 <code>float</code>입니다. <code>float</code>은 다음과 같이 이미지 주위를 텍스트로 감싸기 위해 만들어진 것입니다."

clear.title: "clear"
clear.floating: "마치 떠 있는 것만 같아요!"
clear.1: "<code>clear</code> 프로퍼티는 <code>float</code>의 동작 방식을 제어하는 데 중요합니다. 아래의 두 예제를 비교해 봅시다."
clear.2: "이 경우 <code>section</code> 엘리먼트는 실제로 <code>div</code> 다음에 있습니다. 하지만 <code>div</code>가 왼쪽으로 떠 있기 때문에 이런 결과가 나타난 것입니다. 즉, <code>section</code> 안의 텍스트가 <code>div</code> 주위에 떠 있고 <code>section</code>이 전체를 감싸고 있습니다. <code>section</code>을 실제로 떠 있는 엘리먼트 다음에 나타나게 하려면 어떻게 해야 할까요?"
clear.3: "<code>clear</code>를 이용해 이제 이 섹션을 떠 있는 <code>div</code> 아래로 옮겼습니다. 여기서는 <code>left</code> 값을 지정해 왼쪽에 떠 있는 엘리먼트들을 비웠습니다. 게다가 오른쪽(<code>right</code>)과 양쪽(<code>both</code>)도 비울 수 있습니다."
clearfix.title: "clearfix 핵"
clearfix.1: "다음은 <code>float</code>를 사용할 때 때때로 일어날 수 있는 이상하고 바람직하지 않은 경우입니다."
clearfix.2: "이런... 이 이미지는 그것을 담고 있는 엘리먼트보다 높이가 높고 떠 있어서 컨테이너 바깥으로 넘쳤습니다!"
clearfix.3: "이 문제를 해결하는 방법이 하나 있긴 하지만 조금 지저분합니다. 이를 <em>clearfix 핵</em>이라고 합니다."
clearfix.4: "다음과 같은 CSS 코드를 새로 추가해 봅시다."
clearfix.5: "이제 어떻게 되는지 확인해 봅시다."
clearfix.6: "훨씬 낫네요!"
clearfix.7: "이 기법은 근래에 나온 브라우저에만 동작합니다. IE6를 지원하고 싶다면 다음과 같은 코드를 추가해야 합니다."
clearfix.8: "이 기법을 쓸 때 좀 더 주의를 기울여야 할 특이한 브라우저들도 있습니다. <a href=\"http://stackoverflow.com/questions/211383/which-method-of-clearfix-is-best\">clearfix의 세계는 굉장히 소름끼치지만</a> 이 간단한 해법은 대부분의 브라우저에 효과가 있을 것입니다."

float_layout.title: "float를 이용한 레이아웃 예제"
float_layout.1: "<code>float</code>를 이용해 전체 레이아웃을 잡는 일도 굉장히 자주 접할 수 있습니다. 다음은 앞에서 <code>position</code>으로 잡은 레이아웃을 <code>float</code>로 잡은 레이아웃 예제입니다."
float_layout.2: "이 예제는 앞에서 만든 예제처럼 동작합니다. 컨테이너에 <code>clearfix</code>를 지정한 것을 눈여겨보세요. 이 예제에는 필요하지 않지만 <code>nav</code>가 더는 뜨지 않는 콘텐츠라면 필요할 것입니다."

percent.title: "퍼센트 너비"
percent.1: "퍼센트는 특정 엘리먼트를 담고 있는 블록에 상대적인 측정 단위입니다. 퍼센트는 이미지에 쓰기에 아주 좋습니다. 다음은 항상 컨테이너 너비의 50%만 차지하는 이미지를 만드는 예제입니다. 페이지 크기를 줄이면 어떻게 되는지 확인해 보세요!"
percent.2: "이미지의 크기를 제한하는 데 <code>min-width</code>와 <code>max-width</code>를 사용할 수도 있습니다."
percent.layout.title: "퍼센트 너비 레이아웃"
percent.layout.1: "레이아웃을 잡는 데 퍼센트를 쓸 수도 있지만 이렇게 하면 작업량이 많아질 수 있습니다. 이 예제에서는 창의 너비가 너무 좁을 경우 <code>nav</code> 콘텐츠가 지저분하게 표시되기 시작합니다. 결국 콘텐츠에 알맞는 방식을 선택할 필요가 있습니다."
percent.layout.2: "이 레이아웃이 너무 좁을 경우 <code>nav</code>의 레이아웃이 깨집니다. 더 안 좋은 점은 이 문제를 해결하기 위해 <code>min-width</code>를 사용할 수도 없다는 점입니다. 오른쪽 칼럼이 그것을 받아들이지 않기 때문입니다."

media_queries.title: "미디어 쿼리"
media_queries.1: "\"반응형 디자인\"은 사이트가 표시되는 브라우저와 디바이스에 \"반응하는\" 사이트를 만드는 전략입니다."
media_queries.2: "미디어 쿼리는 이렇게 하는 가장 강력한 도구입니다. 아래의 퍼센트 너비를 사용하는 레이아웃을 가지고 메뉴를 사이드바에 놓기에는 브라우저 창의 크기가 너무 작을 때 메뉴가 한 칼럼에 표시되도록 만들어 봅시다."
media_queries.3: "이제 브라우저 크기를 조절하면 레이아웃이 굉장히 멋지게 바뀝니다!"
media_queries.4: "짜잔! 이제 레이아웃이 모바일 브라우저에서도 멋지게 보입니다. <a href=\"http://mediaqueri.es/\">이런 식으로 미디어 쿼리를 사용하는 인기 사이트들을 확인하려면 이곳을 클릭하세요</a>. <code>min-width</code>와 <code>max-width</code> 말고도 알아낼 수 있는 것이 굉장히 많습니다. 이와 관련된 자세한 사항을 알고 싶다면 <a href=\"https://developer.mozilla.org/en-US/docs/CSS/Media_queries\">MDN 문서</a>를 참고하세요."
media_queries.5: "<a href=\"http://dev.opera.com/articles/view/an-introduction-to-meta-viewport-and-viewport/\">메타 뷰포트(meta viewport)</a>를 이용하면 레이아웃을 모바일에서도 훨씬 더 나은 모습으로 보이게 할 수 있습니다."

inline_block.title: "inline-block"
inline_block.1: "브라우저 너비를 채우고 알맞게 줄바꿈되는 박스 그리드를 만들 수 있는데, 그동안 이러한 박스 그리드를 만드는 방법은 <code>float</code>를 이용하는 것이었습니다. 하지만 이제 <code>inline-block</code>을 이용하면 만들기가 훨씬 더 쉽습니다. <code>inline-block</code> 엘리먼트는 <code>inline</code> 엘리먼트와 비슷하지만 너비와 높이를 지정할 수 있습니다. 두 접근법의 예제를 모두 살펴봅시다."
inline_block.hard_way.title: "힘든 방법(<code>float</code>를 이용)"
inline_block.hard_way.box: "저는 지금 떠 있어요!"
inline_block.hard_way.after: "저한테는 <code>clear</code>가 지정돼 있어서 위에 나열된 박스 옆으로 배치되지 않아요."
inline_block.easy_way.title: "쉬운 방법(<code>inline-block</code>을 이용)"
inline_block.easy_way.info: "<code>display</code> 프로퍼티에 <code>inline-block</code> 값을 이용하면 똑같은 효과를 낼 수 있습니다."
inline_block.easy_way.box: "저는 인라인 블록입니다!"
inline_block.easy_way.after: "이 경우에는 <code>clear</code>를 쓰지 않아도 됩니다. 멋지네요!"
inline_block.2: "<a href=\"http://blog.mozilla.org/webdev/2009/02/20/cross-browser-inline-block/\">IE6와 IE7에서 <code>inline-block</code>을 지원하려면</a> 별도의 작업을 더 해야 합니다. 때때로 <code>inline-block</code>이 <code>hasLayout</code>이라고 하는 것을 발생시킨다고 이야기하는 분들도 있지만 기존 브라우저를 지원하려면 그것에 대해서만 알면 됩니다. 더 자세한 사항이 궁금하다면 IE6와 IE7 지원에 관해 앞에서 알려준 링크를 참고하세요. 그럼 계속 진행해 봅시다."

inline_block_layout.title: "inline-block 레이아웃"
inline_block_layout.1: "레이아웃을 잡기 위해 <code>inline-block</code>을 사용할 수도 있습니다. 이때 몇 가지 염두에 둘 점이 있습니다."
inline_block_layout.caveat.1: "<code>inline-block</code> 엘리먼트는 <code>vertical-align</code> 프로퍼티의 영향을 받습니다(아마 이 프로퍼티는 <code>top</code>으로 설정하고 싶을 겁니다)."
inline_block_layout.caveat.2: "각 칼럼의 너비를 설정할 필요가 있습니다."
inline_block_layout.caveat.3: "HTML의 각 칼럼 사이에 공백이 있으면 칼럼 간에 틈이 생깁니다."
inline_block_layout.tada: "짜잔!"

column.title: "칼럼"
column.1: "다중 칼럼 텍스트를 손쉽게 만들 수 있는 CSS 프로퍼티가 새로 생겼습니다. 한번 살펴보시죠."
column.2: "CSS 칼럼은 아주 최근에 생겼기 때문에 접두사를 사용할 필요가 있으며, <a href=\"http://caniuse.com/#search=column\">IE9까지 또는 오페라 미니</a>에서는 동작하지 않습니다. 칼럼과 관련된 프로퍼티가 좀 더 있으므로 <a href=\"http://www.quirksmode.org/css/multicolumn.html\">더 자세한 사항에 대해서는 이곳을 클릭하세요</a>. 그렇지 않으면 다음 주제로 넘어갑시다."

flexbox.title: "flexbox"
flexbox.1: "새로운 <code>flexbox</code> 레이아웃 모드는 우리가 CSS로 레이아웃을 잡는 방법을 재정의할 기세입니다. 아쉽게도 <code>flexbox</code> 규격이 최근에 상당히 많이 바뀌었기 때문에 각 브라우저마다 다른 식으로 구현돼 있습니다. 그럼에도 어떤 것인지 알아두는 차원에서 몇 가지 예제를 공유하고자 합니다. 여기서 선보이는 예제는 현재 <a href=\"http://www.w3.org/TR/css3-flexbox/\">최신 버전의 표준</a>을 사용하는 <a href=\"http://caniuse.com/flexbox\">일부 브라우저</a>에서만 동작합니다."
flexbox.2: "<code>flexbox</code>와 관련된 오래된 자료가 굉장히 많습니다. <code>flexbox</code>에 관해 좀 더 배우고 싶다면 참고 자료가 최신 내용을 반영하고 있는지 확인하는 방법을 배울 수 있도록 <a href=\"http://css-tricks.com/old-flexbox-and-new-flexbox/\">이곳에서 시작하세요</a>. 저도 <a href=\"http://weblog.bocoup.com/dive-into-flexbox/\">최신 구문을 이용하는 상세한 글</a>을 쓴 적이 있습니다."
flexbox.3: "<code>flexbox</code>를 이용해서 할 수 있는 일은 아주 많습니다. 영감을 주는 차원에서 몇 가지 예제를 알려주자면 다음과 같습니다."
flexbox.simple.title: "<code>flexbox</code>를 이용한 간단한 레이아웃"
flexbox.simple.1: "<code>flexbox</code>는 엄청 쉬워요!"
flexbox.fancy.title: "<code>flexbox</code>를 이용한 멋진 레이아웃"
flexbox.fancy.1: "전 여유 공간이 있으면 200px까지 늘어나고, 여유 공간이 없으면 100px까지 줄어들지만 그 이하로 더 작아지지는 않아요."
flexbox.fancy.2: "전 항상 200px이에요."
flexbox.fancy.3: "전 나머지 너비의 1/3을 채워요."
flexbox.fancy.4: "전 나머지 너비의 2/3를 채워요."
flexbox.centering.title: "<code>flexbox</code>를 이용한 중앙 정렬"
flexbox.centering.1: "마침내 CSS에서도 뭔가를 수직 중앙에 두는 것이 쉬워졌군요!"

frameworks.title: "CSS 프레임워크"
frameworks.1: "CSS 레이아웃은 굉장히 까다로워서 이를 손쉽게 만들어주는 CSS 프레임워크가 있습니다. 다음은 이러한 CSS 프레임워크를 나열한 것입니다. 프레임워크를 사용하는 것은 프레임워크가 실제로 여러분의 사이트가 해주었으면 하는 일을 해줄 때에만 유의미합니다. 프레임워크는 CSS의 작동 방식에 관한 지식을 결코 대신할 수 없습니다."
frameworks.2: "이제 끝났습니다! 이 사이트에 관해 피드백할 사항이 있다면 <a href=\"https://twitter.com/intent/tweet?source=webclient&text=%40_gsmith\">트위터를 통해 저한테 알려주세요</a>!"

about.title: "사이트 소개"
about.credits: "내용 구성 및 사이트 제작: <a href=\"http://incompl.com\">그렉 스미스(Greg Smith)</a>. 디자인: <a href=\"http://www.isaacdurazo.com/\">이삭 두라조(Isaac Durazo)</a>. 저희는 <a href=\"http://bocoup.com\">보쿱(Bocoup)</a>에 근무하고 있습니다."

